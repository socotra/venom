/*
OpenAPI definition

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package policy

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// PoliciesControllerAPIService PoliciesControllerAPI service
type PoliciesControllerAPIService service

type ApiAddPolicyContactRequest struct {
	ctx           context.Context
	ApiService    *PoliciesControllerAPIService
	policyLocator string
	contactRoles  *ContactRoles
}

func (r ApiAddPolicyContactRequest) ContactRoles(contactRoles ContactRoles) ApiAddPolicyContactRequest {
	r.contactRoles = &contactRoles
	return r
}

func (r ApiAddPolicyContactRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.AddPolicyContactExecute(r)
}

/*
AddPolicyContact Method for AddPolicyContact

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyLocator
	@return ApiAddPolicyContactRequest
*/
func (a *PoliciesControllerAPIService) AddPolicyContact(ctx context.Context, policyLocator string) ApiAddPolicyContactRequest {
	return ApiAddPolicyContactRequest{
		ApiService:    a,
		ctx:           ctx,
		policyLocator: policyLocator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) AddPolicyContactExecute(r ApiAddPolicyContactRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.AddPolicyContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{policyLocator}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"policyLocator"+"}", url.PathEscape(parameterValueToString(r.policyLocator, "policyLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contactRoles == nil {
		return localVarReturnValue, nil, reportError("contactRoles is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contactRoles
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddStaticData1Request struct {
	ctx         context.Context
	ApiService  *PoliciesControllerAPIService
	locator     string
	requestBody *map[string]map[string]interface{}
}

func (r ApiAddStaticData1Request) RequestBody(requestBody map[string]map[string]interface{}) ApiAddStaticData1Request {
	r.requestBody = &requestBody
	return r
}

func (r ApiAddStaticData1Request) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.AddStaticData1Execute(r)
}

/*
AddStaticData1 Method for AddStaticData1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiAddStaticData1Request
*/
func (a *PoliciesControllerAPIService) AddStaticData1(ctx context.Context, locator string) ApiAddStaticData1Request {
	return ApiAddStaticData1Request{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) AddStaticData1Execute(r ApiAddStaticData1Request) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.AddStaticData1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/static"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelPolicyRequest struct {
	ctx                     context.Context
	ApiService              *PoliciesControllerAPIService
	locator                 string
	paramsChangeInstruction *ParamsChangeInstruction
	baseLocator             *string
}

func (r ApiCancelPolicyRequest) ParamsChangeInstruction(paramsChangeInstruction ParamsChangeInstruction) ApiCancelPolicyRequest {
	r.paramsChangeInstruction = &paramsChangeInstruction
	return r
}

func (r ApiCancelPolicyRequest) BaseLocator(baseLocator string) ApiCancelPolicyRequest {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiCancelPolicyRequest) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.CancelPolicyExecute(r)
}

/*
CancelPolicy Method for CancelPolicy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiCancelPolicyRequest
*/
func (a *PoliciesControllerAPIService) CancelPolicy(ctx context.Context, locator string) ApiCancelPolicyRequest {
	return ApiCancelPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return Transaction
func (a *PoliciesControllerAPIService) CancelPolicyExecute(r ApiCancelPolicyRequest) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.CancelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paramsChangeInstruction == nil {
		return localVarReturnValue, nil, reportError("paramsChangeInstruction is required and must be specified")
	}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paramsChangeInstruction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangePolicyRequest struct {
	ctx                         context.Context
	ApiService                  *PoliciesControllerAPIService
	locator                     string
	addChangeInstructionRequest *[]AddChangeInstructionRequest
	baseLocator                 *string
}

func (r ApiChangePolicyRequest) AddChangeInstructionRequest(addChangeInstructionRequest []AddChangeInstructionRequest) ApiChangePolicyRequest {
	r.addChangeInstructionRequest = &addChangeInstructionRequest
	return r
}

func (r ApiChangePolicyRequest) BaseLocator(baseLocator string) ApiChangePolicyRequest {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiChangePolicyRequest) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.ChangePolicyExecute(r)
}

/*
ChangePolicy Method for ChangePolicy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiChangePolicyRequest
*/
func (a *PoliciesControllerAPIService) ChangePolicy(ctx context.Context, locator string) ApiChangePolicyRequest {
	return ApiChangePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return Transaction
func (a *PoliciesControllerAPIService) ChangePolicyExecute(r ApiChangePolicyRequest) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ChangePolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/change"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addChangeInstructionRequest == nil {
		return localVarReturnValue, nil, reportError("addChangeInstructionRequest is required and must be specified")
	}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addChangeInstructionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePolicyContactRequest struct {
	ctx            context.Context
	ApiService     *PoliciesControllerAPIService
	policyLocator  string
	contactLocator string
}

func (r ApiDeletePolicyContactRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.DeletePolicyContactExecute(r)
}

/*
DeletePolicyContact Method for DeletePolicyContact

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyLocator
	@param contactLocator
	@return ApiDeletePolicyContactRequest
*/
func (a *PoliciesControllerAPIService) DeletePolicyContact(ctx context.Context, policyLocator string, contactLocator string) ApiDeletePolicyContactRequest {
	return ApiDeletePolicyContactRequest{
		ApiService:     a,
		ctx:            ctx,
		policyLocator:  policyLocator,
		contactLocator: contactLocator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) DeletePolicyContactExecute(r ApiDeletePolicyContactRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.DeletePolicyContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{policyLocator}/contacts/{contactLocator}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyLocator"+"}", url.PathEscape(parameterValueToString(r.policyLocator, "policyLocator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contactLocator"+"}", url.PathEscape(parameterValueToString(r.contactLocator, "contactLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchPoliciesWithNumberRequest struct {
	ctx          context.Context
	ApiService   *PoliciesControllerAPIService
	policyNumber string
}

func (r ApiFetchPoliciesWithNumberRequest) Execute() ([]PolicyResponse, *http.Response, error) {
	return r.ApiService.FetchPoliciesWithNumberExecute(r)
}

/*
FetchPoliciesWithNumber Method for FetchPoliciesWithNumber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyNumber
	@return ApiFetchPoliciesWithNumberRequest
*/
func (a *PoliciesControllerAPIService) FetchPoliciesWithNumber(ctx context.Context, policyNumber string) ApiFetchPoliciesWithNumberRequest {
	return ApiFetchPoliciesWithNumberRequest{
		ApiService:   a,
		ctx:          ctx,
		policyNumber: policyNumber,
	}
}

// Execute executes the request
//
//	@return []PolicyResponse
func (a *PoliciesControllerAPIService) FetchPoliciesWithNumberExecute(r ApiFetchPoliciesWithNumberRequest) ([]PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.FetchPoliciesWithNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/numbers/{policyNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyNumber"+"}", url.PathEscape(parameterValueToString(r.policyNumber, "policyNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchPolicyRequest struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	locator    string
}

func (r ApiFetchPolicyRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.FetchPolicyExecute(r)
}

/*
FetchPolicy Method for FetchPolicy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchPolicyRequest
*/
func (a *PoliciesControllerAPIService) FetchPolicy(ctx context.Context, locator string) ApiFetchPolicyRequest {
	return ApiFetchPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) FetchPolicyExecute(r ApiFetchPolicyRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.FetchPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchPolicyContactsRequest struct {
	ctx           context.Context
	ApiService    *PoliciesControllerAPIService
	policyLocator string
}

func (r ApiFetchPolicyContactsRequest) Execute() ([]ContactRoles, *http.Response, error) {
	return r.ApiService.FetchPolicyContactsExecute(r)
}

/*
FetchPolicyContacts Method for FetchPolicyContacts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyLocator
	@return ApiFetchPolicyContactsRequest
*/
func (a *PoliciesControllerAPIService) FetchPolicyContacts(ctx context.Context, policyLocator string) ApiFetchPolicyContactsRequest {
	return ApiFetchPolicyContactsRequest{
		ApiService:    a,
		ctx:           ctx,
		policyLocator: policyLocator,
	}
}

// Execute executes the request
//
//	@return []ContactRoles
func (a *PoliciesControllerAPIService) FetchPolicyContactsExecute(r ApiFetchPolicyContactsRequest) ([]ContactRoles, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ContactRoles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.FetchPolicyContacts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{policyLocator}/contacts"
	localVarPath = strings.Replace(localVarPath, "{"+"policyLocator"+"}", url.PathEscape(parameterValueToString(r.policyLocator, "policyLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchStaticData1Request struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	locator    string
}

func (r ApiFetchStaticData1Request) Execute() (map[string]map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchStaticData1Execute(r)
}

/*
FetchStaticData1 Method for FetchStaticData1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchStaticData1Request
*/
func (a *PoliciesControllerAPIService) FetchStaticData1(ctx context.Context, locator string) ApiFetchStaticData1Request {
	return ApiFetchStaticData1Request{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return map[string]map[string]interface{}
func (a *PoliciesControllerAPIService) FetchStaticData1Execute(r ApiFetchStaticData1Request) (map[string]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.FetchStaticData1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/static"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGeneratePolicyNumberRequest struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	locator    string
}

func (r ApiGeneratePolicyNumberRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.GeneratePolicyNumberExecute(r)
}

/*
GeneratePolicyNumber Method for GeneratePolicyNumber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiGeneratePolicyNumberRequest
*/
func (a *PoliciesControllerAPIService) GeneratePolicyNumber(ctx context.Context, locator string) ApiGeneratePolicyNumberRequest {
	return ApiGeneratePolicyNumberRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) GeneratePolicyNumberExecute(r ApiGeneratePolicyNumberRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.GeneratePolicyNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/number/generate"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTermSummary1Request struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	locator    string
	termNumber *int32
}

func (r ApiGetTermSummary1Request) TermNumber(termNumber int32) ApiGetTermSummary1Request {
	r.termNumber = &termNumber
	return r
}

func (r ApiGetTermSummary1Request) Execute() (*TermSummary, *http.Response, error) {
	return r.ApiService.GetTermSummary1Execute(r)
}

/*
GetTermSummary1 Method for GetTermSummary1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiGetTermSummary1Request
*/
func (a *PoliciesControllerAPIService) GetTermSummary1(ctx context.Context, locator string) ApiGetTermSummary1Request {
	return ApiGetTermSummary1Request{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return TermSummary
func (a *PoliciesControllerAPIService) GetTermSummary1Execute(r ApiGetTermSummary1Request) (*TermSummary, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TermSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.GetTermSummary1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.termNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "termNumber", r.termNumber, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIssuedTransactionsRequest struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	locator    string
	offset     *int32
	count      *int32
	extended   *bool
}

func (r ApiListIssuedTransactionsRequest) Offset(offset int32) ApiListIssuedTransactionsRequest {
	r.offset = &offset
	return r
}

func (r ApiListIssuedTransactionsRequest) Count(count int32) ApiListIssuedTransactionsRequest {
	r.count = &count
	return r
}

func (r ApiListIssuedTransactionsRequest) Extended(extended bool) ApiListIssuedTransactionsRequest {
	r.extended = &extended
	return r
}

func (r ApiListIssuedTransactionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListIssuedTransactionsExecute(r)
}

/*
ListIssuedTransactions Method for ListIssuedTransactions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiListIssuedTransactionsRequest
*/
func (a *PoliciesControllerAPIService) ListIssuedTransactions(ctx context.Context, locator string) ApiListIssuedTransactionsRequest {
	return ApiListIssuedTransactionsRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *PoliciesControllerAPIService) ListIssuedTransactionsExecute(r ApiListIssuedTransactionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ListIssuedTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/issuedTransactions/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPolicySnapshotsRequest struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	offset     *int32
	count      *int32
}

func (r ApiListPolicySnapshotsRequest) Offset(offset int32) ApiListPolicySnapshotsRequest {
	r.offset = &offset
	return r
}

func (r ApiListPolicySnapshotsRequest) Count(count int32) ApiListPolicySnapshotsRequest {
	r.count = &count
	return r
}

func (r ApiListPolicySnapshotsRequest) Execute() ([]PolicySnapshotResponse, *http.Response, error) {
	return r.ApiService.ListPolicySnapshotsExecute(r)
}

/*
ListPolicySnapshots Method for ListPolicySnapshots

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPolicySnapshotsRequest

Deprecated
*/
func (a *PoliciesControllerAPIService) ListPolicySnapshots(ctx context.Context) ApiListPolicySnapshotsRequest {
	return ApiListPolicySnapshotsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []PolicySnapshotResponse
//
// Deprecated
func (a *PoliciesControllerAPIService) ListPolicySnapshotsExecute(r ApiListPolicySnapshotsRequest) ([]PolicySnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []PolicySnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ListPolicySnapshots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/snapshot/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStaticData1Request struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	locator    string
	offset     *int32
	count      *int32
}

func (r ApiListStaticData1Request) Offset(offset int32) ApiListStaticData1Request {
	r.offset = &offset
	return r
}

func (r ApiListStaticData1Request) Count(count int32) ApiListStaticData1Request {
	r.count = &count
	return r
}

func (r ApiListStaticData1Request) Execute() (*ListPageResponseStaticDataHistoryResponse, *http.Response, error) {
	return r.ApiService.ListStaticData1Execute(r)
}

/*
ListStaticData1 Method for ListStaticData1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiListStaticData1Request
*/
func (a *PoliciesControllerAPIService) ListStaticData1(ctx context.Context, locator string) ApiListStaticData1Request {
	return ApiListStaticData1Request{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return ListPageResponseStaticDataHistoryResponse
func (a *PoliciesControllerAPIService) ListStaticData1Execute(r ApiListStaticData1Request) (*ListPageResponseStaticDataHistoryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPageResponseStaticDataHistoryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ListStaticData1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/static/history/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTermsRequest struct {
	ctx        context.Context
	ApiService *PoliciesControllerAPIService
	locator    string
	offset     *int32
	count      *int32
	extended   *bool
}

func (r ApiListTermsRequest) Offset(offset int32) ApiListTermsRequest {
	r.offset = &offset
	return r
}

func (r ApiListTermsRequest) Count(count int32) ApiListTermsRequest {
	r.count = &count
	return r
}

func (r ApiListTermsRequest) Extended(extended bool) ApiListTermsRequest {
	r.extended = &extended
	return r
}

func (r ApiListTermsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListTermsExecute(r)
}

/*
ListTerms Method for ListTerms

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiListTermsRequest
*/
func (a *PoliciesControllerAPIService) ListTerms(ctx context.Context, locator string) ApiListTermsRequest {
	return ApiListTermsRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *PoliciesControllerAPIService) ListTermsExecute(r ApiListTermsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ListTerms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/terms/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNamedTransactionCreateRequest struct {
	ctx                         context.Context
	ApiService                  *PoliciesControllerAPIService
	locator                     string
	transactionType             string
	addChangeInstructionRequest *[]AddChangeInstructionRequest
	baseLocator                 *string
}

func (r ApiNamedTransactionCreateRequest) AddChangeInstructionRequest(addChangeInstructionRequest []AddChangeInstructionRequest) ApiNamedTransactionCreateRequest {
	r.addChangeInstructionRequest = &addChangeInstructionRequest
	return r
}

func (r ApiNamedTransactionCreateRequest) BaseLocator(baseLocator string) ApiNamedTransactionCreateRequest {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiNamedTransactionCreateRequest) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.NamedTransactionCreateExecute(r)
}

/*
NamedTransactionCreate Method for NamedTransactionCreate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@param transactionType
	@return ApiNamedTransactionCreateRequest
*/
func (a *PoliciesControllerAPIService) NamedTransactionCreate(ctx context.Context, locator string, transactionType string) ApiNamedTransactionCreateRequest {
	return ApiNamedTransactionCreateRequest{
		ApiService:      a,
		ctx:             ctx,
		locator:         locator,
		transactionType: transactionType,
	}
}

// Execute executes the request
//
//	@return Transaction
func (a *PoliciesControllerAPIService) NamedTransactionCreateExecute(r ApiNamedTransactionCreateRequest) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.NamedTransactionCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/{transactionType}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionType"+"}", url.PathEscape(parameterValueToString(r.transactionType, "transactionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addChangeInstructionRequest == nil {
		return localVarReturnValue, nil, reportError("addChangeInstructionRequest is required and must be specified")
	}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addChangeInstructionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicySnapshotRequest struct {
	ctx          context.Context
	ApiService   *PoliciesControllerAPIService
	locator      string
	date         *time.Time
	byIssuedTime *bool
}

func (r ApiPolicySnapshotRequest) Date(date time.Time) ApiPolicySnapshotRequest {
	r.date = &date
	return r
}

func (r ApiPolicySnapshotRequest) ByIssuedTime(byIssuedTime bool) ApiPolicySnapshotRequest {
	r.byIssuedTime = &byIssuedTime
	return r
}

func (r ApiPolicySnapshotRequest) Execute() (*PolicySnapshotResponse, *http.Response, error) {
	return r.ApiService.PolicySnapshotExecute(r)
}

/*
PolicySnapshot Method for PolicySnapshot

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiPolicySnapshotRequest
*/
func (a *PoliciesControllerAPIService) PolicySnapshot(ctx context.Context, locator string) ApiPolicySnapshotRequest {
	return ApiPolicySnapshotRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicySnapshotResponse
func (a *PoliciesControllerAPIService) PolicySnapshotExecute(r ApiPolicySnapshotRequest) (*PolicySnapshotResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicySnapshotResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.PolicySnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/snapshot"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.date == nil {
		return localVarReturnValue, nil, reportError("date is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "form", "")
	if r.byIssuedTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "byIssuedTime", r.byIssuedTime, "form", "")
	} else {
		var defaultValue bool = false
		r.byIssuedTime = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPricePreview1Request struct {
	ctx                         context.Context
	ApiService                  *PoliciesControllerAPIService
	locator                     string
	transactionType             string
	addChangeInstructionRequest *[]AddChangeInstructionRequest
	baseLocator                 *string
}

func (r ApiPricePreview1Request) AddChangeInstructionRequest(addChangeInstructionRequest []AddChangeInstructionRequest) ApiPricePreview1Request {
	r.addChangeInstructionRequest = &addChangeInstructionRequest
	return r
}

func (r ApiPricePreview1Request) BaseLocator(baseLocator string) ApiPricePreview1Request {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiPricePreview1Request) Execute() (*TransactionPriceResponse, *http.Response, error) {
	return r.ApiService.PricePreview1Execute(r)
}

/*
PricePreview1 Method for PricePreview1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@param transactionType
	@return ApiPricePreview1Request
*/
func (a *PoliciesControllerAPIService) PricePreview1(ctx context.Context, locator string, transactionType string) ApiPricePreview1Request {
	return ApiPricePreview1Request{
		ApiService:      a,
		ctx:             ctx,
		locator:         locator,
		transactionType: transactionType,
	}
}

// Execute executes the request
//
//	@return TransactionPriceResponse
func (a *PoliciesControllerAPIService) PricePreview1Execute(r ApiPricePreview1Request) (*TransactionPriceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TransactionPriceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.PricePreview1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/{transactionType}/pricePreview"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionType"+"}", url.PathEscape(parameterValueToString(r.transactionType, "transactionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addChangeInstructionRequest == nil {
		return localVarReturnValue, nil, reportError("addChangeInstructionRequest is required and must be specified")
	}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addChangeInstructionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReinstatePolicyRequest struct {
	ctx                     context.Context
	ApiService              *PoliciesControllerAPIService
	locator                 string
	baseLocator             *string
	paramsChangeInstruction *ParamsChangeInstruction
}

func (r ApiReinstatePolicyRequest) BaseLocator(baseLocator string) ApiReinstatePolicyRequest {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiReinstatePolicyRequest) ParamsChangeInstruction(paramsChangeInstruction ParamsChangeInstruction) ApiReinstatePolicyRequest {
	r.paramsChangeInstruction = &paramsChangeInstruction
	return r
}

func (r ApiReinstatePolicyRequest) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.ReinstatePolicyExecute(r)
}

/*
ReinstatePolicy Method for ReinstatePolicy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiReinstatePolicyRequest
*/
func (a *PoliciesControllerAPIService) ReinstatePolicy(ctx context.Context, locator string) ApiReinstatePolicyRequest {
	return ApiReinstatePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return Transaction
func (a *PoliciesControllerAPIService) ReinstatePolicyExecute(r ApiReinstatePolicyRequest) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ReinstatePolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/reinstate"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.paramsChangeInstruction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRenewPolicyRequest struct {
	ctx                         context.Context
	ApiService                  *PoliciesControllerAPIService
	locator                     string
	addChangeInstructionRequest *[]AddChangeInstructionRequest
	baseLocator                 *string
}

func (r ApiRenewPolicyRequest) AddChangeInstructionRequest(addChangeInstructionRequest []AddChangeInstructionRequest) ApiRenewPolicyRequest {
	r.addChangeInstructionRequest = &addChangeInstructionRequest
	return r
}

func (r ApiRenewPolicyRequest) BaseLocator(baseLocator string) ApiRenewPolicyRequest {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiRenewPolicyRequest) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.RenewPolicyExecute(r)
}

/*
RenewPolicy Method for RenewPolicy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiRenewPolicyRequest
*/
func (a *PoliciesControllerAPIService) RenewPolicy(ctx context.Context, locator string) ApiRenewPolicyRequest {
	return ApiRenewPolicyRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return Transaction
func (a *PoliciesControllerAPIService) RenewPolicyExecute(r ApiRenewPolicyRequest) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.RenewPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/renew"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addChangeInstructionRequest == nil {
		return localVarReturnValue, nil, reportError("addChangeInstructionRequest is required and must be specified")
	}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addChangeInstructionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceStaticData1Request struct {
	ctx         context.Context
	ApiService  *PoliciesControllerAPIService
	locator     string
	requestBody *map[string]map[string]interface{}
}

func (r ApiReplaceStaticData1Request) RequestBody(requestBody map[string]map[string]interface{}) ApiReplaceStaticData1Request {
	r.requestBody = &requestBody
	return r
}

func (r ApiReplaceStaticData1Request) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.ReplaceStaticData1Execute(r)
}

/*
ReplaceStaticData1 Method for ReplaceStaticData1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiReplaceStaticData1Request
*/
func (a *PoliciesControllerAPIService) ReplaceStaticData1(ctx context.Context, locator string) ApiReplaceStaticData1Request {
	return ApiReplaceStaticData1Request{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) ReplaceStaticData1Execute(r ApiReplaceStaticData1Request) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ReplaceStaticData1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/static"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReversePolicyChangeRequest struct {
	ctx                   context.Context
	ApiService            *PoliciesControllerAPIService
	locator               string
	policyReversalRequest *PolicyReversalRequest
}

func (r ApiReversePolicyChangeRequest) PolicyReversalRequest(policyReversalRequest PolicyReversalRequest) ApiReversePolicyChangeRequest {
	r.policyReversalRequest = &policyReversalRequest
	return r
}

func (r ApiReversePolicyChangeRequest) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.ReversePolicyChangeExecute(r)
}

/*
ReversePolicyChange Method for ReversePolicyChange

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiReversePolicyChangeRequest
*/
func (a *PoliciesControllerAPIService) ReversePolicyChange(ctx context.Context, locator string) ApiReversePolicyChangeRequest {
	return ApiReversePolicyChangeRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return Transaction
func (a *PoliciesControllerAPIService) ReversePolicyChangeExecute(r ApiReversePolicyChangeRequest) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ReversePolicyChange")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/reversal"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyReversalRequest == nil {
		return localVarReturnValue, nil, reportError("policyReversalRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyReversalRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetPolicyNumberRequest struct {
	ctx          context.Context
	ApiService   *PoliciesControllerAPIService
	locator      string
	policyNumber *string
}

func (r ApiSetPolicyNumberRequest) PolicyNumber(policyNumber string) ApiSetPolicyNumberRequest {
	r.policyNumber = &policyNumber
	return r
}

func (r ApiSetPolicyNumberRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.SetPolicyNumberExecute(r)
}

/*
SetPolicyNumber Method for SetPolicyNumber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiSetPolicyNumberRequest
*/
func (a *PoliciesControllerAPIService) SetPolicyNumber(ctx context.Context, locator string) ApiSetPolicyNumberRequest {
	return ApiSetPolicyNumberRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) SetPolicyNumberExecute(r ApiSetPolicyNumberRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.SetPolicyNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/number/set"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyNumber == nil {
		return localVarReturnValue, nil, reportError("policyNumber is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "policyNumber", r.policyNumber, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnderwritePreviewRequest struct {
	ctx                         context.Context
	ApiService                  *PoliciesControllerAPIService
	locator                     string
	transactionType             string
	addChangeInstructionRequest *[]AddChangeInstructionRequest
	baseLocator                 *string
}

func (r ApiUnderwritePreviewRequest) AddChangeInstructionRequest(addChangeInstructionRequest []AddChangeInstructionRequest) ApiUnderwritePreviewRequest {
	r.addChangeInstructionRequest = &addChangeInstructionRequest
	return r
}

func (r ApiUnderwritePreviewRequest) BaseLocator(baseLocator string) ApiUnderwritePreviewRequest {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiUnderwritePreviewRequest) Execute() (*TransactionUnderwriteResponse, *http.Response, error) {
	return r.ApiService.UnderwritePreviewExecute(r)
}

/*
UnderwritePreview Method for UnderwritePreview

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@param transactionType
	@return ApiUnderwritePreviewRequest
*/
func (a *PoliciesControllerAPIService) UnderwritePreview(ctx context.Context, locator string, transactionType string) ApiUnderwritePreviewRequest {
	return ApiUnderwritePreviewRequest{
		ApiService:      a,
		ctx:             ctx,
		locator:         locator,
		transactionType: transactionType,
	}
}

// Execute executes the request
//
//	@return TransactionUnderwriteResponse
func (a *PoliciesControllerAPIService) UnderwritePreviewExecute(r ApiUnderwritePreviewRequest) (*TransactionUnderwriteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TransactionUnderwriteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UnderwritePreview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/{transactionType}/underwritePreview"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionType"+"}", url.PathEscape(parameterValueToString(r.transactionType, "transactionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addChangeInstructionRequest == nil {
		return localVarReturnValue, nil, reportError("addChangeInstructionRequest is required and must be specified")
	}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addChangeInstructionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePolicyAutoRenewalPlanRequest struct {
	ctx                   context.Context
	ApiService            *PoliciesControllerAPIService
	locator               string
	updateAutoRenewalPlan *UpdateAutoRenewalPlan
}

func (r ApiUpdatePolicyAutoRenewalPlanRequest) UpdateAutoRenewalPlan(updateAutoRenewalPlan UpdateAutoRenewalPlan) ApiUpdatePolicyAutoRenewalPlanRequest {
	r.updateAutoRenewalPlan = &updateAutoRenewalPlan
	return r
}

func (r ApiUpdatePolicyAutoRenewalPlanRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.UpdatePolicyAutoRenewalPlanExecute(r)
}

/*
UpdatePolicyAutoRenewalPlan Method for UpdatePolicyAutoRenewalPlan

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiUpdatePolicyAutoRenewalPlanRequest
*/
func (a *PoliciesControllerAPIService) UpdatePolicyAutoRenewalPlan(ctx context.Context, locator string) ApiUpdatePolicyAutoRenewalPlanRequest {
	return ApiUpdatePolicyAutoRenewalPlanRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) UpdatePolicyAutoRenewalPlanExecute(r ApiUpdatePolicyAutoRenewalPlanRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UpdatePolicyAutoRenewalPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/autoRenewalPlan"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAutoRenewalPlan == nil {
		return localVarReturnValue, nil, reportError("updateAutoRenewalPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAutoRenewalPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePolicyBillingLevelRequest struct {
	ctx                       context.Context
	ApiService                *PoliciesControllerAPIService
	locator                   string
	updateBillingLevelRequest *UpdateBillingLevelRequest
}

func (r ApiUpdatePolicyBillingLevelRequest) UpdateBillingLevelRequest(updateBillingLevelRequest UpdateBillingLevelRequest) ApiUpdatePolicyBillingLevelRequest {
	r.updateBillingLevelRequest = &updateBillingLevelRequest
	return r
}

func (r ApiUpdatePolicyBillingLevelRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.UpdatePolicyBillingLevelExecute(r)
}

/*
UpdatePolicyBillingLevel Method for UpdatePolicyBillingLevel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiUpdatePolicyBillingLevelRequest
*/
func (a *PoliciesControllerAPIService) UpdatePolicyBillingLevel(ctx context.Context, locator string) ApiUpdatePolicyBillingLevelRequest {
	return ApiUpdatePolicyBillingLevelRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) UpdatePolicyBillingLevelExecute(r ApiUpdatePolicyBillingLevelRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UpdatePolicyBillingLevel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/billingLevel"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateBillingLevelRequest == nil {
		return localVarReturnValue, nil, reportError("updateBillingLevelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateBillingLevelRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePolicyBillingTriggerRequest struct {
	ctx                  context.Context
	ApiService           *PoliciesControllerAPIService
	locator              string
	updateBillingTrigger *UpdateBillingTrigger
}

func (r ApiUpdatePolicyBillingTriggerRequest) UpdateBillingTrigger(updateBillingTrigger UpdateBillingTrigger) ApiUpdatePolicyBillingTriggerRequest {
	r.updateBillingTrigger = &updateBillingTrigger
	return r
}

func (r ApiUpdatePolicyBillingTriggerRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.UpdatePolicyBillingTriggerExecute(r)
}

/*
UpdatePolicyBillingTrigger Method for UpdatePolicyBillingTrigger

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiUpdatePolicyBillingTriggerRequest

Deprecated
*/
func (a *PoliciesControllerAPIService) UpdatePolicyBillingTrigger(ctx context.Context, locator string) ApiUpdatePolicyBillingTriggerRequest {
	return ApiUpdatePolicyBillingTriggerRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
//
// Deprecated
func (a *PoliciesControllerAPIService) UpdatePolicyBillingTriggerExecute(r ApiUpdatePolicyBillingTriggerRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UpdatePolicyBillingTrigger")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/billingTrigger"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateBillingTrigger == nil {
		return localVarReturnValue, nil, reportError("updateBillingTrigger is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateBillingTrigger
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePolicyContactRequest struct {
	ctx                             context.Context
	ApiService                      *PoliciesControllerAPIService
	policyLocator                   string
	contactLocator                  string
	contactAssociationUpdateRequest *ContactAssociationUpdateRequest
}

func (r ApiUpdatePolicyContactRequest) ContactAssociationUpdateRequest(contactAssociationUpdateRequest ContactAssociationUpdateRequest) ApiUpdatePolicyContactRequest {
	r.contactAssociationUpdateRequest = &contactAssociationUpdateRequest
	return r
}

func (r ApiUpdatePolicyContactRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.UpdatePolicyContactExecute(r)
}

/*
UpdatePolicyContact Method for UpdatePolicyContact

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyLocator
	@param contactLocator
	@return ApiUpdatePolicyContactRequest
*/
func (a *PoliciesControllerAPIService) UpdatePolicyContact(ctx context.Context, policyLocator string, contactLocator string) ApiUpdatePolicyContactRequest {
	return ApiUpdatePolicyContactRequest{
		ApiService:     a,
		ctx:            ctx,
		policyLocator:  policyLocator,
		contactLocator: contactLocator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) UpdatePolicyContactExecute(r ApiUpdatePolicyContactRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UpdatePolicyContact")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{policyLocator}/contacts/{contactLocator}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyLocator"+"}", url.PathEscape(parameterValueToString(r.policyLocator, "policyLocator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contactLocator"+"}", url.PathEscape(parameterValueToString(r.contactLocator, "contactLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contactAssociationUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("contactAssociationUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contactAssociationUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePolicyDelinquencyPlanRequest struct {
	ctx                   context.Context
	ApiService            *PoliciesControllerAPIService
	locator               string
	updateDelinquencyPlan *UpdateDelinquencyPlan
}

func (r ApiUpdatePolicyDelinquencyPlanRequest) UpdateDelinquencyPlan(updateDelinquencyPlan UpdateDelinquencyPlan) ApiUpdatePolicyDelinquencyPlanRequest {
	r.updateDelinquencyPlan = &updateDelinquencyPlan
	return r
}

func (r ApiUpdatePolicyDelinquencyPlanRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.UpdatePolicyDelinquencyPlanExecute(r)
}

/*
UpdatePolicyDelinquencyPlan Method for UpdatePolicyDelinquencyPlan

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiUpdatePolicyDelinquencyPlanRequest
*/
func (a *PoliciesControllerAPIService) UpdatePolicyDelinquencyPlan(ctx context.Context, locator string) ApiUpdatePolicyDelinquencyPlanRequest {
	return ApiUpdatePolicyDelinquencyPlanRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) UpdatePolicyDelinquencyPlanExecute(r ApiUpdatePolicyDelinquencyPlanRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UpdatePolicyDelinquencyPlan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/delinquencyPlan"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateDelinquencyPlan == nil {
		return localVarReturnValue, nil, reportError("updateDelinquencyPlan is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateDelinquencyPlan
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePolicyInvoiceFeeAmountRequest struct {
	ctx                           context.Context
	ApiService                    *PoliciesControllerAPIService
	locator                       string
	updateInvoiceFeeAmountRequest *UpdateInvoiceFeeAmountRequest
}

func (r ApiUpdatePolicyInvoiceFeeAmountRequest) UpdateInvoiceFeeAmountRequest(updateInvoiceFeeAmountRequest UpdateInvoiceFeeAmountRequest) ApiUpdatePolicyInvoiceFeeAmountRequest {
	r.updateInvoiceFeeAmountRequest = &updateInvoiceFeeAmountRequest
	return r
}

func (r ApiUpdatePolicyInvoiceFeeAmountRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.UpdatePolicyInvoiceFeeAmountExecute(r)
}

/*
UpdatePolicyInvoiceFeeAmount Method for UpdatePolicyInvoiceFeeAmount

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiUpdatePolicyInvoiceFeeAmountRequest
*/
func (a *PoliciesControllerAPIService) UpdatePolicyInvoiceFeeAmount(ctx context.Context, locator string) ApiUpdatePolicyInvoiceFeeAmountRequest {
	return ApiUpdatePolicyInvoiceFeeAmountRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) UpdatePolicyInvoiceFeeAmountExecute(r ApiUpdatePolicyInvoiceFeeAmountRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UpdatePolicyInvoiceFeeAmount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/invoiceFeeAmount"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateInvoiceFeeAmountRequest == nil {
		return localVarReturnValue, nil, reportError("updateInvoiceFeeAmountRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateInvoiceFeeAmountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateStaticDataRequest struct {
	ctx                    context.Context
	ApiService             *PoliciesControllerAPIService
	locator                string
	patchStaticDataRequest *PatchStaticDataRequest
}

func (r ApiUpdateStaticDataRequest) PatchStaticDataRequest(patchStaticDataRequest PatchStaticDataRequest) ApiUpdateStaticDataRequest {
	r.patchStaticDataRequest = &patchStaticDataRequest
	return r
}

func (r ApiUpdateStaticDataRequest) Execute() (*PolicyResponse, *http.Response, error) {
	return r.ApiService.UpdateStaticDataExecute(r)
}

/*
UpdateStaticData Method for UpdateStaticData

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiUpdateStaticDataRequest
*/
func (a *PoliciesControllerAPIService) UpdateStaticData(ctx context.Context, locator string) ApiUpdateStaticDataRequest {
	return ApiUpdateStaticDataRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return PolicyResponse
func (a *PoliciesControllerAPIService) UpdateStaticDataExecute(r ApiUpdateStaticDataRequest) (*PolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.UpdateStaticData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/static"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchStaticDataRequest == nil {
		return localVarReturnValue, nil, reportError("patchStaticDataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchStaticDataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidatePreview1Request struct {
	ctx                         context.Context
	ApiService                  *PoliciesControllerAPIService
	locator                     string
	transactionType             string
	addChangeInstructionRequest *[]AddChangeInstructionRequest
	baseLocator                 *string
}

func (r ApiValidatePreview1Request) AddChangeInstructionRequest(addChangeInstructionRequest []AddChangeInstructionRequest) ApiValidatePreview1Request {
	r.addChangeInstructionRequest = &addChangeInstructionRequest
	return r
}

func (r ApiValidatePreview1Request) BaseLocator(baseLocator string) ApiValidatePreview1Request {
	r.baseLocator = &baseLocator
	return r
}

func (r ApiValidatePreview1Request) Execute() (*Transaction, *http.Response, error) {
	return r.ApiService.ValidatePreview1Execute(r)
}

/*
ValidatePreview1 Method for ValidatePreview1

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@param transactionType
	@return ApiValidatePreview1Request
*/
func (a *PoliciesControllerAPIService) ValidatePreview1(ctx context.Context, locator string, transactionType string) ApiValidatePreview1Request {
	return ApiValidatePreview1Request{
		ApiService:      a,
		ctx:             ctx,
		locator:         locator,
		transactionType: transactionType,
	}
}

// Execute executes the request
//
//	@return Transaction
func (a *PoliciesControllerAPIService) ValidatePreview1Execute(r ApiValidatePreview1Request) (*Transaction, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PoliciesControllerAPIService.ValidatePreview1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/policies/{locator}/{transactionType}/validatePreview"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transactionType"+"}", url.PathEscape(parameterValueToString(r.transactionType, "transactionType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addChangeInstructionRequest == nil {
		return localVarReturnValue, nil, reportError("addChangeInstructionRequest is required and must be specified")
	}

	if r.baseLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseLocator", r.baseLocator, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addChangeInstructionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
