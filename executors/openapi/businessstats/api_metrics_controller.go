/*
OpenAPI definition

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package businessstats

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

// MetricsControllerAPIService MetricsControllerAPI service
type MetricsControllerAPIService service

type ApiDownloadConversionRateRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiDownloadConversionRateRequest) MetricRequest(metricRequest MetricRequest) ApiDownloadConversionRateRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiDownloadConversionRateRequest) Offset(offset int32) ApiDownloadConversionRateRequest {
	r.offset = &offset
	return r
}

func (r ApiDownloadConversionRateRequest) Count(count int32) ApiDownloadConversionRateRequest {
	r.count = &count
	return r
}

func (r ApiDownloadConversionRateRequest) BackfillZeroes(backfillZeroes bool) ApiDownloadConversionRateRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiDownloadConversionRateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadConversionRateExecute(r)
}

/*
DownloadConversionRate Method for DownloadConversionRate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadConversionRateRequest
*/
func (a *MetricsControllerAPIService) DownloadConversionRate(ctx context.Context) ApiDownloadConversionRateRequest {
	return ApiDownloadConversionRateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetricsControllerAPIService) DownloadConversionRateExecute(r ApiDownloadConversionRateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.DownloadConversionRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/conversionRate/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadExpiredPoliciesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiDownloadExpiredPoliciesRequest) MetricRequest(metricRequest MetricRequest) ApiDownloadExpiredPoliciesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiDownloadExpiredPoliciesRequest) Offset(offset int32) ApiDownloadExpiredPoliciesRequest {
	r.offset = &offset
	return r
}

func (r ApiDownloadExpiredPoliciesRequest) Count(count int32) ApiDownloadExpiredPoliciesRequest {
	r.count = &count
	return r
}

func (r ApiDownloadExpiredPoliciesRequest) BackfillZeroes(backfillZeroes bool) ApiDownloadExpiredPoliciesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiDownloadExpiredPoliciesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadExpiredPoliciesExecute(r)
}

/*
DownloadExpiredPolicies Method for DownloadExpiredPolicies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadExpiredPoliciesRequest
*/
func (a *MetricsControllerAPIService) DownloadExpiredPolicies(ctx context.Context) ApiDownloadExpiredPoliciesRequest {
	return ApiDownloadExpiredPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetricsControllerAPIService) DownloadExpiredPoliciesExecute(r ApiDownloadExpiredPoliciesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.DownloadExpiredPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/expiredPolicies/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadGWPRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiDownloadGWPRequest) MetricRequest(metricRequest MetricRequest) ApiDownloadGWPRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiDownloadGWPRequest) Offset(offset int32) ApiDownloadGWPRequest {
	r.offset = &offset
	return r
}

func (r ApiDownloadGWPRequest) Count(count int32) ApiDownloadGWPRequest {
	r.count = &count
	return r
}

func (r ApiDownloadGWPRequest) BackfillZeroes(backfillZeroes bool) ApiDownloadGWPRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiDownloadGWPRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadGWPExecute(r)
}

/*
DownloadGWP Method for DownloadGWP

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadGWPRequest
*/
func (a *MetricsControllerAPIService) DownloadGWP(ctx context.Context) ApiDownloadGWPRequest {
	return ApiDownloadGWPRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetricsControllerAPIService) DownloadGWPExecute(r ApiDownloadGWPRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.DownloadGWP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/gwp/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadIssuedPoliciesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiDownloadIssuedPoliciesRequest) MetricRequest(metricRequest MetricRequest) ApiDownloadIssuedPoliciesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiDownloadIssuedPoliciesRequest) Offset(offset int32) ApiDownloadIssuedPoliciesRequest {
	r.offset = &offset
	return r
}

func (r ApiDownloadIssuedPoliciesRequest) Count(count int32) ApiDownloadIssuedPoliciesRequest {
	r.count = &count
	return r
}

func (r ApiDownloadIssuedPoliciesRequest) BackfillZeroes(backfillZeroes bool) ApiDownloadIssuedPoliciesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiDownloadIssuedPoliciesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadIssuedPoliciesExecute(r)
}

/*
DownloadIssuedPolicies Method for DownloadIssuedPolicies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadIssuedPoliciesRequest
*/
func (a *MetricsControllerAPIService) DownloadIssuedPolicies(ctx context.Context) ApiDownloadIssuedPoliciesRequest {
	return ApiDownloadIssuedPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetricsControllerAPIService) DownloadIssuedPoliciesExecute(r ApiDownloadIssuedPoliciesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.DownloadIssuedPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/issued/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadPricedQuotesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiDownloadPricedQuotesRequest) MetricRequest(metricRequest MetricRequest) ApiDownloadPricedQuotesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiDownloadPricedQuotesRequest) Offset(offset int32) ApiDownloadPricedQuotesRequest {
	r.offset = &offset
	return r
}

func (r ApiDownloadPricedQuotesRequest) Count(count int32) ApiDownloadPricedQuotesRequest {
	r.count = &count
	return r
}

func (r ApiDownloadPricedQuotesRequest) BackfillZeroes(backfillZeroes bool) ApiDownloadPricedQuotesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiDownloadPricedQuotesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadPricedQuotesExecute(r)
}

/*
DownloadPricedQuotes Method for DownloadPricedQuotes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadPricedQuotesRequest
*/
func (a *MetricsControllerAPIService) DownloadPricedQuotes(ctx context.Context) ApiDownloadPricedQuotesRequest {
	return ApiDownloadPricedQuotesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetricsControllerAPIService) DownloadPricedQuotesExecute(r ApiDownloadPricedQuotesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.DownloadPricedQuotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/quotes/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadRenewalRateRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiDownloadRenewalRateRequest) MetricRequest(metricRequest MetricRequest) ApiDownloadRenewalRateRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiDownloadRenewalRateRequest) Offset(offset int32) ApiDownloadRenewalRateRequest {
	r.offset = &offset
	return r
}

func (r ApiDownloadRenewalRateRequest) Count(count int32) ApiDownloadRenewalRateRequest {
	r.count = &count
	return r
}

func (r ApiDownloadRenewalRateRequest) BackfillZeroes(backfillZeroes bool) ApiDownloadRenewalRateRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiDownloadRenewalRateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadRenewalRateExecute(r)
}

/*
DownloadRenewalRate Method for DownloadRenewalRate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadRenewalRateRequest
*/
func (a *MetricsControllerAPIService) DownloadRenewalRate(ctx context.Context) ApiDownloadRenewalRateRequest {
	return ApiDownloadRenewalRateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetricsControllerAPIService) DownloadRenewalRateExecute(r ApiDownloadRenewalRateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.DownloadRenewalRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/renewalRate/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadRenewedPoliciesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiDownloadRenewedPoliciesRequest) MetricRequest(metricRequest MetricRequest) ApiDownloadRenewedPoliciesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiDownloadRenewedPoliciesRequest) Offset(offset int32) ApiDownloadRenewedPoliciesRequest {
	r.offset = &offset
	return r
}

func (r ApiDownloadRenewedPoliciesRequest) Count(count int32) ApiDownloadRenewedPoliciesRequest {
	r.count = &count
	return r
}

func (r ApiDownloadRenewedPoliciesRequest) BackfillZeroes(backfillZeroes bool) ApiDownloadRenewedPoliciesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiDownloadRenewedPoliciesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DownloadRenewedPoliciesExecute(r)
}

/*
DownloadRenewedPolicies Method for DownloadRenewedPolicies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDownloadRenewedPoliciesRequest
*/
func (a *MetricsControllerAPIService) DownloadRenewedPolicies(ctx context.Context) ApiDownloadRenewedPoliciesRequest {
	return ApiDownloadRenewedPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MetricsControllerAPIService) DownloadRenewedPoliciesExecute(r ApiDownloadRenewedPoliciesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.DownloadRenewedPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/renewedPolicies/download"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversionRateRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiGetConversionRateRequest) MetricRequest(metricRequest MetricRequest) ApiGetConversionRateRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiGetConversionRateRequest) Offset(offset int32) ApiGetConversionRateRequest {
	r.offset = &offset
	return r
}

func (r ApiGetConversionRateRequest) Count(count int32) ApiGetConversionRateRequest {
	r.count = &count
	return r
}

func (r ApiGetConversionRateRequest) BackfillZeroes(backfillZeroes bool) ApiGetConversionRateRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiGetConversionRateRequest) Execute() (*MetricResponse, *http.Response, error) {
	return r.ApiService.GetConversionRateExecute(r)
}

/*
GetConversionRate Method for GetConversionRate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetConversionRateRequest
*/
func (a *MetricsControllerAPIService) GetConversionRate(ctx context.Context) ApiGetConversionRateRequest {
	return ApiGetConversionRateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MetricResponse
func (a *MetricsControllerAPIService) GetConversionRateExecute(r ApiGetConversionRateRequest) (*MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.GetConversionRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/conversionRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExpiredPoliciesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiGetExpiredPoliciesRequest) MetricRequest(metricRequest MetricRequest) ApiGetExpiredPoliciesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiGetExpiredPoliciesRequest) Offset(offset int32) ApiGetExpiredPoliciesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetExpiredPoliciesRequest) Count(count int32) ApiGetExpiredPoliciesRequest {
	r.count = &count
	return r
}

func (r ApiGetExpiredPoliciesRequest) BackfillZeroes(backfillZeroes bool) ApiGetExpiredPoliciesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiGetExpiredPoliciesRequest) Execute() (*MetricResponse, *http.Response, error) {
	return r.ApiService.GetExpiredPoliciesExecute(r)
}

/*
GetExpiredPolicies Method for GetExpiredPolicies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetExpiredPoliciesRequest
*/
func (a *MetricsControllerAPIService) GetExpiredPolicies(ctx context.Context) ApiGetExpiredPoliciesRequest {
	return ApiGetExpiredPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MetricResponse
func (a *MetricsControllerAPIService) GetExpiredPoliciesExecute(r ApiGetExpiredPoliciesRequest) (*MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.GetExpiredPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/expiredPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGWPRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiGetGWPRequest) MetricRequest(metricRequest MetricRequest) ApiGetGWPRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiGetGWPRequest) Offset(offset int32) ApiGetGWPRequest {
	r.offset = &offset
	return r
}

func (r ApiGetGWPRequest) Count(count int32) ApiGetGWPRequest {
	r.count = &count
	return r
}

func (r ApiGetGWPRequest) BackfillZeroes(backfillZeroes bool) ApiGetGWPRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiGetGWPRequest) Execute() (*MetricResponse, *http.Response, error) {
	return r.ApiService.GetGWPExecute(r)
}

/*
GetGWP Method for GetGWP

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetGWPRequest
*/
func (a *MetricsControllerAPIService) GetGWP(ctx context.Context) ApiGetGWPRequest {
	return ApiGetGWPRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MetricResponse
func (a *MetricsControllerAPIService) GetGWPExecute(r ApiGetGWPRequest) (*MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.GetGWP")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/gwp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIssuedPoliciesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiGetIssuedPoliciesRequest) MetricRequest(metricRequest MetricRequest) ApiGetIssuedPoliciesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiGetIssuedPoliciesRequest) Offset(offset int32) ApiGetIssuedPoliciesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetIssuedPoliciesRequest) Count(count int32) ApiGetIssuedPoliciesRequest {
	r.count = &count
	return r
}

func (r ApiGetIssuedPoliciesRequest) BackfillZeroes(backfillZeroes bool) ApiGetIssuedPoliciesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiGetIssuedPoliciesRequest) Execute() (*MetricResponse, *http.Response, error) {
	return r.ApiService.GetIssuedPoliciesExecute(r)
}

/*
GetIssuedPolicies Method for GetIssuedPolicies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetIssuedPoliciesRequest
*/
func (a *MetricsControllerAPIService) GetIssuedPolicies(ctx context.Context) ApiGetIssuedPoliciesRequest {
	return ApiGetIssuedPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MetricResponse
func (a *MetricsControllerAPIService) GetIssuedPoliciesExecute(r ApiGetIssuedPoliciesRequest) (*MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.GetIssuedPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/issued"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPricedQuotesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiGetPricedQuotesRequest) MetricRequest(metricRequest MetricRequest) ApiGetPricedQuotesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiGetPricedQuotesRequest) Offset(offset int32) ApiGetPricedQuotesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetPricedQuotesRequest) Count(count int32) ApiGetPricedQuotesRequest {
	r.count = &count
	return r
}

func (r ApiGetPricedQuotesRequest) BackfillZeroes(backfillZeroes bool) ApiGetPricedQuotesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiGetPricedQuotesRequest) Execute() (*MetricResponse, *http.Response, error) {
	return r.ApiService.GetPricedQuotesExecute(r)
}

/*
GetPricedQuotes Method for GetPricedQuotes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPricedQuotesRequest
*/
func (a *MetricsControllerAPIService) GetPricedQuotes(ctx context.Context) ApiGetPricedQuotesRequest {
	return ApiGetPricedQuotesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MetricResponse
func (a *MetricsControllerAPIService) GetPricedQuotesExecute(r ApiGetPricedQuotesRequest) (*MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.GetPricedQuotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenewalRateRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiGetRenewalRateRequest) MetricRequest(metricRequest MetricRequest) ApiGetRenewalRateRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiGetRenewalRateRequest) Offset(offset int32) ApiGetRenewalRateRequest {
	r.offset = &offset
	return r
}

func (r ApiGetRenewalRateRequest) Count(count int32) ApiGetRenewalRateRequest {
	r.count = &count
	return r
}

func (r ApiGetRenewalRateRequest) BackfillZeroes(backfillZeroes bool) ApiGetRenewalRateRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiGetRenewalRateRequest) Execute() (*MetricResponse, *http.Response, error) {
	return r.ApiService.GetRenewalRateExecute(r)
}

/*
GetRenewalRate Method for GetRenewalRate

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRenewalRateRequest
*/
func (a *MetricsControllerAPIService) GetRenewalRate(ctx context.Context) ApiGetRenewalRateRequest {
	return ApiGetRenewalRateRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MetricResponse
func (a *MetricsControllerAPIService) GetRenewalRateExecute(r ApiGetRenewalRateRequest) (*MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.GetRenewalRate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/renewalRate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRenewedPoliciesRequest struct {
	ctx            context.Context
	ApiService     *MetricsControllerAPIService
	metricRequest  *MetricRequest
	offset         *int32
	count          *int32
	backfillZeroes *bool
}

func (r ApiGetRenewedPoliciesRequest) MetricRequest(metricRequest MetricRequest) ApiGetRenewedPoliciesRequest {
	r.metricRequest = &metricRequest
	return r
}

func (r ApiGetRenewedPoliciesRequest) Offset(offset int32) ApiGetRenewedPoliciesRequest {
	r.offset = &offset
	return r
}

func (r ApiGetRenewedPoliciesRequest) Count(count int32) ApiGetRenewedPoliciesRequest {
	r.count = &count
	return r
}

func (r ApiGetRenewedPoliciesRequest) BackfillZeroes(backfillZeroes bool) ApiGetRenewedPoliciesRequest {
	r.backfillZeroes = &backfillZeroes
	return r
}

func (r ApiGetRenewedPoliciesRequest) Execute() (*MetricResponse, *http.Response, error) {
	return r.ApiService.GetRenewedPoliciesExecute(r)
}

/*
GetRenewedPolicies Method for GetRenewedPolicies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRenewedPoliciesRequest
*/
func (a *MetricsControllerAPIService) GetRenewedPolicies(ctx context.Context) ApiGetRenewedPoliciesRequest {
	return ApiGetRenewedPoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MetricResponse
func (a *MetricsControllerAPIService) GetRenewedPoliciesExecute(r ApiGetRenewedPoliciesRequest) (*MetricResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MetricResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsControllerAPIService.GetRenewedPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metrics/renewedPolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.metricRequest == nil {
		return localVarReturnValue, nil, reportError("metricRequest is required and must be specified")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.backfillZeroes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backfillZeroes", r.backfillZeroes, "form", "")
	} else {
		var defaultValue bool = false
		r.backfillZeroes = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.metricRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
