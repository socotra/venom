/*
OpenAPI definition

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package auxdata

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	
)

// MediaDataControllerAPIService MediaDataControllerAPI service
type MediaDataControllerAPIService service

type ApiCreateMediaDataRequest struct {
	ctx        context.Context
	ApiService *MediaDataControllerAPIService
	filename   *string
	mimeType   *string
	references *[]MediaDataEntryReference
	file       *os.File
	title      *string
	tag        *string
}

func (r ApiCreateMediaDataRequest) Filename(filename string) ApiCreateMediaDataRequest {
	r.filename = &filename
	return r
}

func (r ApiCreateMediaDataRequest) MimeType(mimeType string) ApiCreateMediaDataRequest {
	r.mimeType = &mimeType
	return r
}

func (r ApiCreateMediaDataRequest) References(references []MediaDataEntryReference) ApiCreateMediaDataRequest {
	r.references = &references
	return r
}

func (r ApiCreateMediaDataRequest) File(file *os.File) ApiCreateMediaDataRequest {
	r.file = file
	return r
}

func (r ApiCreateMediaDataRequest) Title(title string) ApiCreateMediaDataRequest {
	r.title = &title
	return r
}

func (r ApiCreateMediaDataRequest) Tag(tag string) ApiCreateMediaDataRequest {
	r.tag = &tag
	return r
}

func (r ApiCreateMediaDataRequest) Execute() (*MediaDataEntry, *http.Response, error) {
	return r.ApiService.CreateMediaDataExecute(r)
}

/*
CreateMediaData Method for CreateMediaData

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateMediaDataRequest
*/
func (a *MediaDataControllerAPIService) CreateMediaData(ctx context.Context) ApiCreateMediaDataRequest {
	return ApiCreateMediaDataRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return MediaDataEntry
func (a *MediaDataControllerAPIService) CreateMediaDataExecute(r ApiCreateMediaDataRequest) (*MediaDataEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MediaDataEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.CreateMediaData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filename == nil {
		return localVarReturnValue, nil, reportError("filename is required and must be specified")
	}
	if r.mimeType == nil {
		return localVarReturnValue, nil, reportError("mimeType is required and must be specified")
	}
	if r.references == nil {
		return localVarReturnValue, nil, reportError("references is required and must be specified")
	}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "mimeType", r.mimeType, "form", "")
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	{
		t := *r.references
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "references", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "references", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMediaDataRequest struct {
	ctx        context.Context
	ApiService *MediaDataControllerAPIService
	locator    string
}

func (r ApiDeleteMediaDataRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteMediaDataExecute(r)
}

/*
DeleteMediaData Method for DeleteMediaData

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiDeleteMediaDataRequest
*/
func (a *MediaDataControllerAPIService) DeleteMediaData(ctx context.Context, locator string) ApiDeleteMediaDataRequest {
	return ApiDeleteMediaDataRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
func (a *MediaDataControllerAPIService) DeleteMediaDataExecute(r ApiDeleteMediaDataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.DeleteMediaData")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFetchAllMediaDataByLocatorRequest struct {
	ctx        context.Context
	ApiService *MediaDataControllerAPIService
	locator    string
	offset     *int32
	count      *int32
	extended   *bool
}

func (r ApiFetchAllMediaDataByLocatorRequest) Offset(offset int32) ApiFetchAllMediaDataByLocatorRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchAllMediaDataByLocatorRequest) Count(count int32) ApiFetchAllMediaDataByLocatorRequest {
	r.count = &count
	return r
}

func (r ApiFetchAllMediaDataByLocatorRequest) Extended(extended bool) ApiFetchAllMediaDataByLocatorRequest {
	r.extended = &extended
	return r
}

func (r ApiFetchAllMediaDataByLocatorRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchAllMediaDataByLocatorExecute(r)
}

/*
FetchAllMediaDataByLocator Method for FetchAllMediaDataByLocator

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchAllMediaDataByLocatorRequest
*/
func (a *MediaDataControllerAPIService) FetchAllMediaDataByLocator(ctx context.Context, locator string) ApiFetchAllMediaDataByLocatorRequest {
	return ApiFetchAllMediaDataByLocatorRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MediaDataControllerAPIService) FetchAllMediaDataByLocatorExecute(r ApiFetchAllMediaDataByLocatorRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.FetchAllMediaDataByLocator")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/{locator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	} else {
		var defaultValue bool = true
		r.extended = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchFileRequest struct {
	ctx            context.Context
	ApiService     *MediaDataControllerAPIService
	locator        string
	versionLocator string
}

func (r ApiFetchFileRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchFileExecute(r)
}

/*
FetchFile Method for FetchFile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@param versionLocator
	@return ApiFetchFileRequest
*/
func (a *MediaDataControllerAPIService) FetchFile(ctx context.Context, locator string, versionLocator string) ApiFetchFileRequest {
	return ApiFetchFileRequest{
		ApiService:     a,
		ctx:            ctx,
		locator:        locator,
		versionLocator: versionLocator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MediaDataControllerAPIService) FetchFileExecute(r ApiFetchFileRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.FetchFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/{locator}/versions/{versionLocator}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionLocator"+"}", url.PathEscape(parameterValueToString(r.versionLocator, "versionLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchLatestFileRequest struct {
	ctx        context.Context
	ApiService *MediaDataControllerAPIService
	locator    string
}

func (r ApiFetchLatestFileRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchLatestFileExecute(r)
}

/*
FetchLatestFile Method for FetchLatestFile

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchLatestFileRequest
*/
func (a *MediaDataControllerAPIService) FetchLatestFile(ctx context.Context, locator string) ApiFetchLatestFileRequest {
	return ApiFetchLatestFileRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MediaDataControllerAPIService) FetchLatestFileExecute(r ApiFetchLatestFileRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.FetchLatestFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/{locator}/file"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchLatestMediaDataRequest struct {
	ctx        context.Context
	ApiService *MediaDataControllerAPIService
	locator    string
}

func (r ApiFetchLatestMediaDataRequest) Execute() (*MediaDataEntry, *http.Response, error) {
	return r.ApiService.FetchLatestMediaDataExecute(r)
}

/*
FetchLatestMediaData Method for FetchLatestMediaData

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchLatestMediaDataRequest
*/
func (a *MediaDataControllerAPIService) FetchLatestMediaData(ctx context.Context, locator string) ApiFetchLatestMediaDataRequest {
	return ApiFetchLatestMediaDataRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return MediaDataEntry
func (a *MediaDataControllerAPIService) FetchLatestMediaDataExecute(r ApiFetchLatestMediaDataRequest) (*MediaDataEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MediaDataEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.FetchLatestMediaData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchLatestMediaDataByReferenceRequest struct {
	ctx              context.Context
	ApiService       *MediaDataControllerAPIService
	referenceLocator string
	referenceType    string
	offset           *int32
	count            *int32
	extended         *bool
}

func (r ApiFetchLatestMediaDataByReferenceRequest) Offset(offset int32) ApiFetchLatestMediaDataByReferenceRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchLatestMediaDataByReferenceRequest) Count(count int32) ApiFetchLatestMediaDataByReferenceRequest {
	r.count = &count
	return r
}

func (r ApiFetchLatestMediaDataByReferenceRequest) Extended(extended bool) ApiFetchLatestMediaDataByReferenceRequest {
	r.extended = &extended
	return r
}

func (r ApiFetchLatestMediaDataByReferenceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchLatestMediaDataByReferenceExecute(r)
}

/*
FetchLatestMediaDataByReference Method for FetchLatestMediaDataByReference

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param referenceLocator
	@param referenceType
	@return ApiFetchLatestMediaDataByReferenceRequest
*/
func (a *MediaDataControllerAPIService) FetchLatestMediaDataByReference(ctx context.Context, referenceLocator string, referenceType string) ApiFetchLatestMediaDataByReferenceRequest {
	return ApiFetchLatestMediaDataByReferenceRequest{
		ApiService:       a,
		ctx:              ctx,
		referenceLocator: referenceLocator,
		referenceType:    referenceType,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *MediaDataControllerAPIService) FetchLatestMediaDataByReferenceExecute(r ApiFetchLatestMediaDataByReferenceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.FetchLatestMediaDataByReference")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/search/{referenceType}/{referenceLocator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"referenceLocator"+"}", url.PathEscape(parameterValueToString(r.referenceLocator, "referenceLocator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"referenceType"+"}", url.PathEscape(parameterValueToString(r.referenceType, "referenceType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	} else {
		var defaultValue bool = true
		r.extended = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchMediaDataRequest struct {
	ctx            context.Context
	ApiService     *MediaDataControllerAPIService
	locator        string
	versionLocator string
}

func (r ApiFetchMediaDataRequest) Execute() (*MediaDataEntry, *http.Response, error) {
	return r.ApiService.FetchMediaDataExecute(r)
}

/*
FetchMediaData Method for FetchMediaData

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@param versionLocator
	@return ApiFetchMediaDataRequest
*/
func (a *MediaDataControllerAPIService) FetchMediaData(ctx context.Context, locator string, versionLocator string) ApiFetchMediaDataRequest {
	return ApiFetchMediaDataRequest{
		ApiService:     a,
		ctx:            ctx,
		locator:        locator,
		versionLocator: versionLocator,
	}
}

// Execute executes the request
//
//	@return MediaDataEntry
func (a *MediaDataControllerAPIService) FetchMediaDataExecute(r ApiFetchMediaDataRequest) (*MediaDataEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MediaDataEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.FetchMediaData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/{locator}/versions/{versionLocator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"versionLocator"+"}", url.PathEscape(parameterValueToString(r.versionLocator, "versionLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMediaDataRequest struct {
	ctx                context.Context
	ApiService         *MediaDataControllerAPIService
	locator            string
	filename           *string
	mimeType           *string
	title              *string
	tag                *string
	referencesToAdd    *[]MediaDataEntryReference
	referencesToRemove *[]MediaDataEntryReference
	file               *os.File
}

func (r ApiUpdateMediaDataRequest) Filename(filename string) ApiUpdateMediaDataRequest {
	r.filename = &filename
	return r
}

func (r ApiUpdateMediaDataRequest) MimeType(mimeType string) ApiUpdateMediaDataRequest {
	r.mimeType = &mimeType
	return r
}

func (r ApiUpdateMediaDataRequest) Title(title string) ApiUpdateMediaDataRequest {
	r.title = &title
	return r
}

func (r ApiUpdateMediaDataRequest) Tag(tag string) ApiUpdateMediaDataRequest {
	r.tag = &tag
	return r
}

func (r ApiUpdateMediaDataRequest) ReferencesToAdd(referencesToAdd []MediaDataEntryReference) ApiUpdateMediaDataRequest {
	r.referencesToAdd = &referencesToAdd
	return r
}

func (r ApiUpdateMediaDataRequest) ReferencesToRemove(referencesToRemove []MediaDataEntryReference) ApiUpdateMediaDataRequest {
	r.referencesToRemove = &referencesToRemove
	return r
}

func (r ApiUpdateMediaDataRequest) File(file *os.File) ApiUpdateMediaDataRequest {
	r.file = file
	return r
}

func (r ApiUpdateMediaDataRequest) Execute() (*MediaDataEntry, *http.Response, error) {
	return r.ApiService.UpdateMediaDataExecute(r)
}

/*
UpdateMediaData Method for UpdateMediaData

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiUpdateMediaDataRequest
*/
func (a *MediaDataControllerAPIService) UpdateMediaData(ctx context.Context, locator string) ApiUpdateMediaDataRequest {
	return ApiUpdateMediaDataRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return MediaDataEntry
func (a *MediaDataControllerAPIService) UpdateMediaDataExecute(r ApiUpdateMediaDataRequest) (*MediaDataEntry, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *MediaDataEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaDataControllerAPIService.UpdateMediaData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/mediadata/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	if r.mimeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mimeType", r.mimeType, "form", "")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.referencesToAdd != nil {
		t := *r.referencesToAdd
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "referencesToAdd", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "referencesToAdd", t, "form", "multi")
		}
	}
	if r.referencesToRemove != nil {
		t := *r.referencesToRemove
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "referencesToRemove", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "referencesToRemove", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
