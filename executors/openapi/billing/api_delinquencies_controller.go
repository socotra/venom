/*
OpenAPI definition

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package billing

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DelinquenciesControllerAPIService DelinquenciesControllerAPI service
type DelinquenciesControllerAPIService service

type ApiGetDelinquenciesForAccountRequest struct {
	ctx            context.Context
	ApiService     *DelinquenciesControllerAPIService
	accountLocator string
	offset         *int32
	count          *int32
	extended       *bool
}

func (r ApiGetDelinquenciesForAccountRequest) Offset(offset int32) ApiGetDelinquenciesForAccountRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDelinquenciesForAccountRequest) Count(count int32) ApiGetDelinquenciesForAccountRequest {
	r.count = &count
	return r
}

func (r ApiGetDelinquenciesForAccountRequest) Extended(extended bool) ApiGetDelinquenciesForAccountRequest {
	r.extended = &extended
	return r
}

func (r ApiGetDelinquenciesForAccountRequest) Execute() (*DelinquencyListResponse, *http.Response, error) {
	return r.ApiService.GetDelinquenciesForAccountExecute(r)
}

/*
GetDelinquenciesForAccount Method for GetDelinquenciesForAccount

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountLocator
	@return ApiGetDelinquenciesForAccountRequest
*/
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForAccount(ctx context.Context, accountLocator string) ApiGetDelinquenciesForAccountRequest {
	return ApiGetDelinquenciesForAccountRequest{
		ApiService:     a,
		ctx:            ctx,
		accountLocator: accountLocator,
	}
}

// Execute executes the request
//
//	@return DelinquencyListResponse
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForAccountExecute(r ApiGetDelinquenciesForAccountRequest) (*DelinquencyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DelinquencyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.GetDelinquenciesForAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/accounts/{accountLocator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"accountLocator"+"}", url.PathEscape(parameterValueToString(r.accountLocator, "accountLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDelinquenciesForInvoiceRequest struct {
	ctx            context.Context
	ApiService     *DelinquenciesControllerAPIService
	invoiceLocator string
	offset         *int32
	count          *int32
	extended       *bool
}

func (r ApiGetDelinquenciesForInvoiceRequest) Offset(offset int32) ApiGetDelinquenciesForInvoiceRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDelinquenciesForInvoiceRequest) Count(count int32) ApiGetDelinquenciesForInvoiceRequest {
	r.count = &count
	return r
}

func (r ApiGetDelinquenciesForInvoiceRequest) Extended(extended bool) ApiGetDelinquenciesForInvoiceRequest {
	r.extended = &extended
	return r
}

func (r ApiGetDelinquenciesForInvoiceRequest) Execute() (*DelinquencyListResponse, *http.Response, error) {
	return r.ApiService.GetDelinquenciesForInvoiceExecute(r)
}

/*
GetDelinquenciesForInvoice Method for GetDelinquenciesForInvoice

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param invoiceLocator
	@return ApiGetDelinquenciesForInvoiceRequest
*/
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForInvoice(ctx context.Context, invoiceLocator string) ApiGetDelinquenciesForInvoiceRequest {
	return ApiGetDelinquenciesForInvoiceRequest{
		ApiService:     a,
		ctx:            ctx,
		invoiceLocator: invoiceLocator,
	}
}

// Execute executes the request
//
//	@return DelinquencyListResponse
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForInvoiceExecute(r ApiGetDelinquenciesForInvoiceRequest) (*DelinquencyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DelinquencyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.GetDelinquenciesForInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/invoices/{invoiceLocator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLocator"+"}", url.PathEscape(parameterValueToString(r.invoiceLocator, "invoiceLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDelinquenciesForPolicyRequest struct {
	ctx           context.Context
	ApiService    *DelinquenciesControllerAPIService
	policyLocator string
	offset        *int32
	count         *int32
	extended      *bool
}

func (r ApiGetDelinquenciesForPolicyRequest) Offset(offset int32) ApiGetDelinquenciesForPolicyRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDelinquenciesForPolicyRequest) Count(count int32) ApiGetDelinquenciesForPolicyRequest {
	r.count = &count
	return r
}

func (r ApiGetDelinquenciesForPolicyRequest) Extended(extended bool) ApiGetDelinquenciesForPolicyRequest {
	r.extended = &extended
	return r
}

func (r ApiGetDelinquenciesForPolicyRequest) Execute() (*DelinquencyListResponse, *http.Response, error) {
	return r.ApiService.GetDelinquenciesForPolicyExecute(r)
}

/*
GetDelinquenciesForPolicy Method for GetDelinquenciesForPolicy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyLocator
	@return ApiGetDelinquenciesForPolicyRequest
*/
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForPolicy(ctx context.Context, policyLocator string) ApiGetDelinquenciesForPolicyRequest {
	return ApiGetDelinquenciesForPolicyRequest{
		ApiService:    a,
		ctx:           ctx,
		policyLocator: policyLocator,
	}
}

// Execute executes the request
//
//	@return DelinquencyListResponse
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForPolicyExecute(r ApiGetDelinquenciesForPolicyRequest) (*DelinquencyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DelinquencyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.GetDelinquenciesForPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/policies/{policyLocator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"policyLocator"+"}", url.PathEscape(parameterValueToString(r.policyLocator, "policyLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDelinquenciesForQuoteRequest struct {
	ctx          context.Context
	ApiService   *DelinquenciesControllerAPIService
	quoteLocator string
	offset       *int32
	count        *int32
	extended     *bool
}

func (r ApiGetDelinquenciesForQuoteRequest) Offset(offset int32) ApiGetDelinquenciesForQuoteRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDelinquenciesForQuoteRequest) Count(count int32) ApiGetDelinquenciesForQuoteRequest {
	r.count = &count
	return r
}

func (r ApiGetDelinquenciesForQuoteRequest) Extended(extended bool) ApiGetDelinquenciesForQuoteRequest {
	r.extended = &extended
	return r
}

func (r ApiGetDelinquenciesForQuoteRequest) Execute() (*DelinquencyListResponse, *http.Response, error) {
	return r.ApiService.GetDelinquenciesForQuoteExecute(r)
}

/*
GetDelinquenciesForQuote Method for GetDelinquenciesForQuote

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param quoteLocator
	@return ApiGetDelinquenciesForQuoteRequest
*/
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForQuote(ctx context.Context, quoteLocator string) ApiGetDelinquenciesForQuoteRequest {
	return ApiGetDelinquenciesForQuoteRequest{
		ApiService:   a,
		ctx:          ctx,
		quoteLocator: quoteLocator,
	}
}

// Execute executes the request
//
//	@return DelinquencyListResponse
func (a *DelinquenciesControllerAPIService) GetDelinquenciesForQuoteExecute(r ApiGetDelinquenciesForQuoteRequest) (*DelinquencyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DelinquencyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.GetDelinquenciesForQuote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/quotes/{quoteLocator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteLocator"+"}", url.PathEscape(parameterValueToString(r.quoteLocator, "quoteLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDelinquencyRequest struct {
	ctx        context.Context
	ApiService *DelinquenciesControllerAPIService
	locator    string
}

func (r ApiGetDelinquencyRequest) Execute() (*Delinquency, *http.Response, error) {
	return r.ApiService.GetDelinquencyExecute(r)
}

/*
GetDelinquency Method for GetDelinquency

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiGetDelinquencyRequest
*/
func (a *DelinquenciesControllerAPIService) GetDelinquency(ctx context.Context, locator string) ApiGetDelinquencyRequest {
	return ApiGetDelinquencyRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return Delinquency
func (a *DelinquenciesControllerAPIService) GetDelinquencyExecute(r ApiGetDelinquencyRequest) (*Delinquency, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Delinquency
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.GetDelinquency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDelinquencyEventRequest struct {
	ctx                     context.Context
	ApiService              *DelinquenciesControllerAPIService
	delinquencyEventLocator string
}

func (r ApiGetDelinquencyEventRequest) Execute() (*DelinquencyEvent, *http.Response, error) {
	return r.ApiService.GetDelinquencyEventExecute(r)
}

/*
GetDelinquencyEvent Method for GetDelinquencyEvent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param delinquencyEventLocator
	@return ApiGetDelinquencyEventRequest
*/
func (a *DelinquenciesControllerAPIService) GetDelinquencyEvent(ctx context.Context, delinquencyEventLocator string) ApiGetDelinquencyEventRequest {
	return ApiGetDelinquencyEventRequest{
		ApiService:              a,
		ctx:                     ctx,
		delinquencyEventLocator: delinquencyEventLocator,
	}
}

// Execute executes the request
//
//	@return DelinquencyEvent
func (a *DelinquenciesControllerAPIService) GetDelinquencyEventExecute(r ApiGetDelinquencyEventRequest) (*DelinquencyEvent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DelinquencyEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.GetDelinquencyEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/events/{delinquencyEventLocator}"
	localVarPath = strings.Replace(localVarPath, "{"+"delinquencyEventLocator"+"}", url.PathEscape(parameterValueToString(r.delinquencyEventLocator, "delinquencyEventLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDelinquencyEventsRequest struct {
	ctx                context.Context
	ApiService         *DelinquenciesControllerAPIService
	delinquencyLocator string
	offset             *int32
	count              *int32
}

func (r ApiGetDelinquencyEventsRequest) Offset(offset int32) ApiGetDelinquencyEventsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetDelinquencyEventsRequest) Count(count int32) ApiGetDelinquencyEventsRequest {
	r.count = &count
	return r
}

func (r ApiGetDelinquencyEventsRequest) Execute() (*DelinquencyEventsResponse, *http.Response, error) {
	return r.ApiService.GetDelinquencyEventsExecute(r)
}

/*
GetDelinquencyEvents Method for GetDelinquencyEvents

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param delinquencyLocator
	@return ApiGetDelinquencyEventsRequest
*/
func (a *DelinquenciesControllerAPIService) GetDelinquencyEvents(ctx context.Context, delinquencyLocator string) ApiGetDelinquencyEventsRequest {
	return ApiGetDelinquencyEventsRequest{
		ApiService:         a,
		ctx:                ctx,
		delinquencyLocator: delinquencyLocator,
	}
}

// Execute executes the request
//
//	@return DelinquencyEventsResponse
func (a *DelinquenciesControllerAPIService) GetDelinquencyEventsExecute(r ApiGetDelinquencyEventsRequest) (*DelinquencyEventsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DelinquencyEventsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.GetDelinquencyEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/{delinquencyLocator}/events/list"
	localVarPath = strings.Replace(localVarPath, "{"+"delinquencyLocator"+"}", url.PathEscape(parameterValueToString(r.delinquencyLocator, "delinquencyLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDelinquencyRequest struct {
	ctx              context.Context
	ApiService       *DelinquenciesControllerAPIService
	locator          string
	patchDelinquency *PatchDelinquency
}

func (r ApiPatchDelinquencyRequest) PatchDelinquency(patchDelinquency PatchDelinquency) ApiPatchDelinquencyRequest {
	r.patchDelinquency = &patchDelinquency
	return r
}

func (r ApiPatchDelinquencyRequest) Execute() (*Delinquency, *http.Response, error) {
	return r.ApiService.PatchDelinquencyExecute(r)
}

/*
PatchDelinquency Method for PatchDelinquency

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiPatchDelinquencyRequest
*/
func (a *DelinquenciesControllerAPIService) PatchDelinquency(ctx context.Context, locator string) ApiPatchDelinquencyRequest {
	return ApiPatchDelinquencyRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return Delinquency
func (a *DelinquenciesControllerAPIService) PatchDelinquencyExecute(r ApiPatchDelinquencyRequest) (*Delinquency, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Delinquency
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.PatchDelinquency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchDelinquency == nil {
		return localVarReturnValue, nil, reportError("patchDelinquency is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchDelinquency
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDelinquencyEventRequest struct {
	ctx                     context.Context
	ApiService              *DelinquenciesControllerAPIService
	delinquencyEventLocator string
	patchDelinquencyEvent   *PatchDelinquencyEvent
}

func (r ApiPatchDelinquencyEventRequest) PatchDelinquencyEvent(patchDelinquencyEvent PatchDelinquencyEvent) ApiPatchDelinquencyEventRequest {
	r.patchDelinquencyEvent = &patchDelinquencyEvent
	return r
}

func (r ApiPatchDelinquencyEventRequest) Execute() (*DelinquencyEvent, *http.Response, error) {
	return r.ApiService.PatchDelinquencyEventExecute(r)
}

/*
PatchDelinquencyEvent Method for PatchDelinquencyEvent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param delinquencyEventLocator
	@return ApiPatchDelinquencyEventRequest
*/
func (a *DelinquenciesControllerAPIService) PatchDelinquencyEvent(ctx context.Context, delinquencyEventLocator string) ApiPatchDelinquencyEventRequest {
	return ApiPatchDelinquencyEventRequest{
		ApiService:              a,
		ctx:                     ctx,
		delinquencyEventLocator: delinquencyEventLocator,
	}
}

// Execute executes the request
//
//	@return DelinquencyEvent
func (a *DelinquenciesControllerAPIService) PatchDelinquencyEventExecute(r ApiPatchDelinquencyEventRequest) (*DelinquencyEvent, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DelinquencyEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DelinquenciesControllerAPIService.PatchDelinquencyEvent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/delinquencies/events/{delinquencyEventLocator}"
	localVarPath = strings.Replace(localVarPath, "{"+"delinquencyEventLocator"+"}", url.PathEscape(parameterValueToString(r.delinquencyEventLocator, "delinquencyEventLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchDelinquencyEvent == nil {
		return localVarReturnValue, nil, reportError("patchDelinquencyEvent is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchDelinquencyEvent
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
