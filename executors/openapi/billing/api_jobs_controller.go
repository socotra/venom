/*
OpenAPI definition

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package billing

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// JobsControllerAPIService JobsControllerAPI service
type JobsControllerAPIService service

type ApiFetchCreateDelinquenciesJobDataForInvoiceRequest struct {
	ctx            context.Context
	ApiService     *JobsControllerAPIService
	invoiceLocator string
	offset         *int32
	count          *int32
	extended       *bool
}

func (r ApiFetchCreateDelinquenciesJobDataForInvoiceRequest) Offset(offset int32) ApiFetchCreateDelinquenciesJobDataForInvoiceRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchCreateDelinquenciesJobDataForInvoiceRequest) Count(count int32) ApiFetchCreateDelinquenciesJobDataForInvoiceRequest {
	r.count = &count
	return r
}

func (r ApiFetchCreateDelinquenciesJobDataForInvoiceRequest) Extended(extended bool) ApiFetchCreateDelinquenciesJobDataForInvoiceRequest {
	r.extended = &extended
	return r
}

func (r ApiFetchCreateDelinquenciesJobDataForInvoiceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchCreateDelinquenciesJobDataForInvoiceExecute(r)
}

/*
FetchCreateDelinquenciesJobDataForInvoice Method for FetchCreateDelinquenciesJobDataForInvoice

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param invoiceLocator
	@return ApiFetchCreateDelinquenciesJobDataForInvoiceRequest
*/
func (a *JobsControllerAPIService) FetchCreateDelinquenciesJobDataForInvoice(ctx context.Context, invoiceLocator string) ApiFetchCreateDelinquenciesJobDataForInvoiceRequest {
	return ApiFetchCreateDelinquenciesJobDataForInvoiceRequest{
		ApiService:     a,
		ctx:            ctx,
		invoiceLocator: invoiceLocator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *JobsControllerAPIService) FetchCreateDelinquenciesJobDataForInvoiceExecute(r ApiFetchCreateDelinquenciesJobDataForInvoiceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchCreateDelinquenciesJobDataForInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/delinquencies/invoices/{invoiceLocator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"invoiceLocator"+"}", url.PathEscape(parameterValueToString(r.invoiceLocator, "invoiceLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchDelinquencyEventJobsRequest struct {
	ctx                context.Context
	ApiService         *JobsControllerAPIService
	delinquencyLocator string
	offset             *int32
	count              *int32
}

func (r ApiFetchDelinquencyEventJobsRequest) Offset(offset int32) ApiFetchDelinquencyEventJobsRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchDelinquencyEventJobsRequest) Count(count int32) ApiFetchDelinquencyEventJobsRequest {
	r.count = &count
	return r
}

func (r ApiFetchDelinquencyEventJobsRequest) Execute() (*ListPageResponseDelinquencyEventJobData, *http.Response, error) {
	return r.ApiService.FetchDelinquencyEventJobsExecute(r)
}

/*
FetchDelinquencyEventJobs Method for FetchDelinquencyEventJobs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param delinquencyLocator
	@return ApiFetchDelinquencyEventJobsRequest
*/
func (a *JobsControllerAPIService) FetchDelinquencyEventJobs(ctx context.Context, delinquencyLocator string) ApiFetchDelinquencyEventJobsRequest {
	return ApiFetchDelinquencyEventJobsRequest{
		ApiService:         a,
		ctx:                ctx,
		delinquencyLocator: delinquencyLocator,
	}
}

// Execute executes the request
//
//	@return ListPageResponseDelinquencyEventJobData
func (a *JobsControllerAPIService) FetchDelinquencyEventJobsExecute(r ApiFetchDelinquencyEventJobsRequest) (*ListPageResponseDelinquencyEventJobData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPageResponseDelinquencyEventJobData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchDelinquencyEventJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/delinquencies/{delinquencyLocator}/events/list"
	localVarPath = strings.Replace(localVarPath, "{"+"delinquencyLocator"+"}", url.PathEscape(parameterValueToString(r.delinquencyLocator, "delinquencyLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchDelinquencyGraceJobRequest struct {
	ctx                context.Context
	ApiService         *JobsControllerAPIService
	delinquencyLocator string
	offset             *int32
	count              *int32
	extended           *bool
}

func (r ApiFetchDelinquencyGraceJobRequest) Offset(offset int32) ApiFetchDelinquencyGraceJobRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchDelinquencyGraceJobRequest) Count(count int32) ApiFetchDelinquencyGraceJobRequest {
	r.count = &count
	return r
}

func (r ApiFetchDelinquencyGraceJobRequest) Extended(extended bool) ApiFetchDelinquencyGraceJobRequest {
	r.extended = &extended
	return r
}

func (r ApiFetchDelinquencyGraceJobRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchDelinquencyGraceJobExecute(r)
}

/*
FetchDelinquencyGraceJob Method for FetchDelinquencyGraceJob

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param delinquencyLocator
	@return ApiFetchDelinquencyGraceJobRequest
*/
func (a *JobsControllerAPIService) FetchDelinquencyGraceJob(ctx context.Context, delinquencyLocator string) ApiFetchDelinquencyGraceJobRequest {
	return ApiFetchDelinquencyGraceJobRequest{
		ApiService:         a,
		ctx:                ctx,
		delinquencyLocator: delinquencyLocator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *JobsControllerAPIService) FetchDelinquencyGraceJobExecute(r ApiFetchDelinquencyGraceJobRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchDelinquencyGraceJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/delinquencies/{delinquencyLocator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"delinquencyLocator"+"}", url.PathEscape(parameterValueToString(r.delinquencyLocator, "delinquencyLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchInstallmentsJobDataForQuotesRequest struct {
	ctx        context.Context
	ApiService *JobsControllerAPIService
	locator    string
	offset     *int32
	count      *int32
	extended   *bool
}

func (r ApiFetchInstallmentsJobDataForQuotesRequest) Offset(offset int32) ApiFetchInstallmentsJobDataForQuotesRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchInstallmentsJobDataForQuotesRequest) Count(count int32) ApiFetchInstallmentsJobDataForQuotesRequest {
	r.count = &count
	return r
}

func (r ApiFetchInstallmentsJobDataForQuotesRequest) Extended(extended bool) ApiFetchInstallmentsJobDataForQuotesRequest {
	r.extended = &extended
	return r
}

func (r ApiFetchInstallmentsJobDataForQuotesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchInstallmentsJobDataForQuotesExecute(r)
}

/*
FetchInstallmentsJobDataForQuotes Method for FetchInstallmentsJobDataForQuotes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchInstallmentsJobDataForQuotesRequest
*/
func (a *JobsControllerAPIService) FetchInstallmentsJobDataForQuotes(ctx context.Context, locator string) ApiFetchInstallmentsJobDataForQuotesRequest {
	return ApiFetchInstallmentsJobDataForQuotesRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *JobsControllerAPIService) FetchInstallmentsJobDataForQuotesExecute(r ApiFetchInstallmentsJobDataForQuotesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchInstallmentsJobDataForQuotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/installments/quotes/{locator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchInstallmentsJobDataForTransactionsRequest struct {
	ctx        context.Context
	ApiService *JobsControllerAPIService
	locator    string
	offset     *int32
	count      *int32
	extended   *bool
}

func (r ApiFetchInstallmentsJobDataForTransactionsRequest) Offset(offset int32) ApiFetchInstallmentsJobDataForTransactionsRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchInstallmentsJobDataForTransactionsRequest) Count(count int32) ApiFetchInstallmentsJobDataForTransactionsRequest {
	r.count = &count
	return r
}

func (r ApiFetchInstallmentsJobDataForTransactionsRequest) Extended(extended bool) ApiFetchInstallmentsJobDataForTransactionsRequest {
	r.extended = &extended
	return r
}

func (r ApiFetchInstallmentsJobDataForTransactionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.FetchInstallmentsJobDataForTransactionsExecute(r)
}

/*
FetchInstallmentsJobDataForTransactions Method for FetchInstallmentsJobDataForTransactions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchInstallmentsJobDataForTransactionsRequest
*/
func (a *JobsControllerAPIService) FetchInstallmentsJobDataForTransactions(ctx context.Context, locator string) ApiFetchInstallmentsJobDataForTransactionsRequest {
	return ApiFetchInstallmentsJobDataForTransactionsRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *JobsControllerAPIService) FetchInstallmentsJobDataForTransactionsExecute(r ApiFetchInstallmentsJobDataForTransactionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchInstallmentsJobDataForTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/installments/transactions/{locator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchInvoiceJobDataForAccountRequest struct {
	ctx        context.Context
	ApiService *JobsControllerAPIService
	locator    string
	offset     *int32
	count      *int32
	extended   *bool
}

func (r ApiFetchInvoiceJobDataForAccountRequest) Offset(offset int32) ApiFetchInvoiceJobDataForAccountRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchInvoiceJobDataForAccountRequest) Count(count int32) ApiFetchInvoiceJobDataForAccountRequest {
	r.count = &count
	return r
}

func (r ApiFetchInvoiceJobDataForAccountRequest) Extended(extended bool) ApiFetchInvoiceJobDataForAccountRequest {
	r.extended = &extended
	return r
}

func (r ApiFetchInvoiceJobDataForAccountRequest) Execute() (*InvoiceGenerationJobListResponse, *http.Response, error) {
	return r.ApiService.FetchInvoiceJobDataForAccountExecute(r)
}

/*
FetchInvoiceJobDataForAccount Method for FetchInvoiceJobDataForAccount

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchInvoiceJobDataForAccountRequest
*/
func (a *JobsControllerAPIService) FetchInvoiceJobDataForAccount(ctx context.Context, locator string) ApiFetchInvoiceJobDataForAccountRequest {
	return ApiFetchInvoiceJobDataForAccountRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return InvoiceGenerationJobListResponse
func (a *JobsControllerAPIService) FetchInvoiceJobDataForAccountExecute(r ApiFetchInvoiceJobDataForAccountRequest) (*InvoiceGenerationJobListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvoiceGenerationJobListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchInvoiceJobDataForAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/invoices/accounts/{locator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchInvoicingJobRequest struct {
	ctx        context.Context
	ApiService *JobsControllerAPIService
	jobLocator string
}

func (r ApiFetchInvoicingJobRequest) Execute() (*InvoicingJobData, *http.Response, error) {
	return r.ApiService.FetchInvoicingJobExecute(r)
}

/*
FetchInvoicingJob Method for FetchInvoicingJob

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobLocator
	@return ApiFetchInvoicingJobRequest
*/
func (a *JobsControllerAPIService) FetchInvoicingJob(ctx context.Context, jobLocator string) ApiFetchInvoicingJobRequest {
	return ApiFetchInvoicingJobRequest{
		ApiService: a,
		ctx:        ctx,
		jobLocator: jobLocator,
	}
}

// Execute executes the request
//
//	@return InvoicingJobData
func (a *JobsControllerAPIService) FetchInvoicingJobExecute(r ApiFetchInvoicingJobRequest) (*InvoicingJobData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvoicingJobData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchInvoicingJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/invoicing/{jobLocator}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobLocator"+"}", url.PathEscape(parameterValueToString(r.jobLocator, "jobLocator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchInvoicingJobsForAccountRequest struct {
	ctx        context.Context
	ApiService *JobsControllerAPIService
	locator    string
	offset     *int32
	count      *int32
}

func (r ApiFetchInvoicingJobsForAccountRequest) Offset(offset int32) ApiFetchInvoicingJobsForAccountRequest {
	r.offset = &offset
	return r
}

func (r ApiFetchInvoicingJobsForAccountRequest) Count(count int32) ApiFetchInvoicingJobsForAccountRequest {
	r.count = &count
	return r
}

func (r ApiFetchInvoicingJobsForAccountRequest) Execute() (*ListPageResponseInvoicingJobData, *http.Response, error) {
	return r.ApiService.FetchInvoicingJobsForAccountExecute(r)
}

/*
FetchInvoicingJobsForAccount Method for FetchInvoicingJobsForAccount

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchInvoicingJobsForAccountRequest
*/
func (a *JobsControllerAPIService) FetchInvoicingJobsForAccount(ctx context.Context, locator string) ApiFetchInvoicingJobsForAccountRequest {
	return ApiFetchInvoicingJobsForAccountRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return ListPageResponseInvoicingJobData
func (a *JobsControllerAPIService) FetchInvoicingJobsForAccountExecute(r ApiFetchInvoicingJobsForAccountRequest) (*ListPageResponseInvoicingJobData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListPageResponseInvoicingJobData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsControllerAPIService.FetchInvoicingJobsForAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/invoicing/accounts/{locator}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
