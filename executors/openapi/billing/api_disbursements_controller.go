/*
OpenAPI definition

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package billing

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DisbursementsControllerAPIService DisbursementsControllerAPI service
type DisbursementsControllerAPIService service

type ApiAddDisbursementRequest struct {
	ctx                                  context.Context
	ApiService                           *DisbursementsControllerAPIService
	disbursementUpdateReplaceDataRequest *DisbursementUpdateReplaceDataRequest
}

func (r ApiAddDisbursementRequest) DisbursementUpdateReplaceDataRequest(disbursementUpdateReplaceDataRequest DisbursementUpdateReplaceDataRequest) ApiAddDisbursementRequest {
	r.disbursementUpdateReplaceDataRequest = &disbursementUpdateReplaceDataRequest
	return r
}

func (r ApiAddDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.AddDisbursementExecute(r)
}

/*
AddDisbursement Method for AddDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) AddDisbursement(ctx context.Context) ApiAddDisbursementRequest {
	return ApiAddDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) AddDisbursementExecute(r ApiAddDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.AddDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disbursementUpdateReplaceDataRequest == nil {
		return localVarReturnValue, nil, reportError("disbursementUpdateReplaceDataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disbursementUpdateReplaceDataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApproveDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiApproveDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.ApproveDisbursementExecute(r)
}

/*
ApproveDisbursement Method for ApproveDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiApproveDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) ApproveDisbursement(ctx context.Context, locator string) ApiApproveDisbursementRequest {
	return ApiApproveDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) ApproveDisbursementExecute(r ApiApproveDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.ApproveDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/approve"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDiscardDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiDiscardDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.DiscardDisbursementExecute(r)
}

/*
DiscardDisbursement Method for DiscardDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiDiscardDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) DiscardDisbursement(ctx context.Context, locator string) ApiDiscardDisbursementRequest {
	return ApiDiscardDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) DiscardDisbursementExecute(r ApiDiscardDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.DiscardDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/discard"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecuteDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiExecuteDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.ExecuteDisbursementExecute(r)
}

/*
ExecuteDisbursement Method for ExecuteDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiExecuteDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) ExecuteDisbursement(ctx context.Context, locator string) ApiExecuteDisbursementRequest {
	return ApiExecuteDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) ExecuteDisbursementExecute(r ApiExecuteDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.ExecuteDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/execute"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiFetchDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.FetchDisbursementExecute(r)
}

/*
FetchDisbursement Method for FetchDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiFetchDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) FetchDisbursement(ctx context.Context, locator string) ApiFetchDisbursementRequest {
	return ApiFetchDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) FetchDisbursementExecute(r ApiFetchDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.FetchDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchDisbursementsWithNumberRequest struct {
	ctx                context.Context
	ApiService         *DisbursementsControllerAPIService
	disbursementNumber string
}

func (r ApiFetchDisbursementsWithNumberRequest) Execute() ([]DisbursementResponse, *http.Response, error) {
	return r.ApiService.FetchDisbursementsWithNumberExecute(r)
}

/*
FetchDisbursementsWithNumber Method for FetchDisbursementsWithNumber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param disbursementNumber
	@return ApiFetchDisbursementsWithNumberRequest
*/
func (a *DisbursementsControllerAPIService) FetchDisbursementsWithNumber(ctx context.Context, disbursementNumber string) ApiFetchDisbursementsWithNumberRequest {
	return ApiFetchDisbursementsWithNumberRequest{
		ApiService:         a,
		ctx:                ctx,
		disbursementNumber: disbursementNumber,
	}
}

// Execute executes the request
//
//	@return []DisbursementResponse
func (a *DisbursementsControllerAPIService) FetchDisbursementsWithNumberExecute(r ApiFetchDisbursementsWithNumberRequest) ([]DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.FetchDisbursementsWithNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/numbers/{disbursementNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"disbursementNumber"+"}", url.PathEscape(parameterValueToString(r.disbursementNumber, "disbursementNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGenerateDisbursementNumberRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiGenerateDisbursementNumberRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.GenerateDisbursementNumberExecute(r)
}

/*
GenerateDisbursementNumber Method for GenerateDisbursementNumber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiGenerateDisbursementNumberRequest
*/
func (a *DisbursementsControllerAPIService) GenerateDisbursementNumber(ctx context.Context, locator string) ApiGenerateDisbursementNumberRequest {
	return ApiGenerateDisbursementNumberRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) GenerateDisbursementNumberExecute(r ApiGenerateDisbursementNumberRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.GenerateDisbursementNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/number/generate"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDisbursementsRequest struct {
	ctx            context.Context
	ApiService     *DisbursementsControllerAPIService
	offset         *int32
	count          *int32
	accountLocator *string
	extended       *bool
}

func (r ApiListDisbursementsRequest) Offset(offset int32) ApiListDisbursementsRequest {
	r.offset = &offset
	return r
}

func (r ApiListDisbursementsRequest) Count(count int32) ApiListDisbursementsRequest {
	r.count = &count
	return r
}

func (r ApiListDisbursementsRequest) AccountLocator(accountLocator string) ApiListDisbursementsRequest {
	r.accountLocator = &accountLocator
	return r
}

func (r ApiListDisbursementsRequest) Extended(extended bool) ApiListDisbursementsRequest {
	r.extended = &extended
	return r
}

func (r ApiListDisbursementsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ListDisbursementsExecute(r)
}

/*
ListDisbursements Method for ListDisbursements

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDisbursementsRequest
*/
func (a *DisbursementsControllerAPIService) ListDisbursements(ctx context.Context) ApiListDisbursementsRequest {
	return ApiListDisbursementsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *DisbursementsControllerAPIService) ListDisbursementsExecute(r ApiListDisbursementsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.ListDisbursements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "form", "")
	}
	if r.accountLocator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountLocator", r.accountLocator, "form", "")
	}
	if r.extended != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extended", r.extended, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchDisbursementRequest struct {
	ctx               context.Context
	ApiService        *DisbursementsControllerAPIService
	locator           string
	patchDisbursement *PatchDisbursement
}

func (r ApiPatchDisbursementRequest) PatchDisbursement(patchDisbursement PatchDisbursement) ApiPatchDisbursementRequest {
	r.patchDisbursement = &patchDisbursement
	return r
}

func (r ApiPatchDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.PatchDisbursementExecute(r)
}

/*
PatchDisbursement Method for PatchDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiPatchDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) PatchDisbursement(ctx context.Context, locator string) ApiPatchDisbursementRequest {
	return ApiPatchDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) PatchDisbursementExecute(r ApiPatchDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.PatchDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchDisbursement == nil {
		return localVarReturnValue, nil, reportError("patchDisbursement is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchDisbursement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDisbursementRequest struct {
	ctx                                  context.Context
	ApiService                           *DisbursementsControllerAPIService
	locator                              string
	disbursementUpdateReplaceDataRequest *DisbursementUpdateReplaceDataRequest
}

func (r ApiPutDisbursementRequest) DisbursementUpdateReplaceDataRequest(disbursementUpdateReplaceDataRequest DisbursementUpdateReplaceDataRequest) ApiPutDisbursementRequest {
	r.disbursementUpdateReplaceDataRequest = &disbursementUpdateReplaceDataRequest
	return r
}

func (r ApiPutDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.PutDisbursementExecute(r)
}

/*
PutDisbursement Method for PutDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiPutDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) PutDisbursement(ctx context.Context, locator string) ApiPutDisbursementRequest {
	return ApiPutDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) PutDisbursementExecute(r ApiPutDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.PutDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disbursementUpdateReplaceDataRequest == nil {
		return localVarReturnValue, nil, reportError("disbursementUpdateReplaceDataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disbursementUpdateReplaceDataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRejectDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiRejectDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.RejectDisbursementExecute(r)
}

/*
RejectDisbursement Method for RejectDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiRejectDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) RejectDisbursement(ctx context.Context, locator string) ApiRejectDisbursementRequest {
	return ApiRejectDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) RejectDisbursementExecute(r ApiRejectDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.RejectDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/reject"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiResetDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.ResetDisbursementExecute(r)
}

/*
ResetDisbursement Method for ResetDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiResetDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) ResetDisbursement(ctx context.Context, locator string) ApiResetDisbursementRequest {
	return ApiResetDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) ResetDisbursementExecute(r ApiResetDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.ResetDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReverseDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiReverseDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.ReverseDisbursementExecute(r)
}

/*
ReverseDisbursement Method for ReverseDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiReverseDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) ReverseDisbursement(ctx context.Context, locator string) ApiReverseDisbursementRequest {
	return ApiReverseDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) ReverseDisbursementExecute(r ApiReverseDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.ReverseDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/reverse"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDisbursementNumberRequest struct {
	ctx                context.Context
	ApiService         *DisbursementsControllerAPIService
	locator            string
	disbursementNumber *string
}

func (r ApiSetDisbursementNumberRequest) DisbursementNumber(disbursementNumber string) ApiSetDisbursementNumberRequest {
	r.disbursementNumber = &disbursementNumber
	return r
}

func (r ApiSetDisbursementNumberRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.SetDisbursementNumberExecute(r)
}

/*
SetDisbursementNumber Method for SetDisbursementNumber

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiSetDisbursementNumberRequest
*/
func (a *DisbursementsControllerAPIService) SetDisbursementNumber(ctx context.Context, locator string) ApiSetDisbursementNumberRequest {
	return ApiSetDisbursementNumberRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) SetDisbursementNumberExecute(r ApiSetDisbursementNumberRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.SetDisbursementNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/number/set"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disbursementNumber == nil {
		return localVarReturnValue, nil, reportError("disbursementNumber is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "disbursementNumber", r.disbursementNumber, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateDisbursementRequest struct {
	ctx        context.Context
	ApiService *DisbursementsControllerAPIService
	locator    string
}

func (r ApiValidateDisbursementRequest) Execute() (*DisbursementResponse, *http.Response, error) {
	return r.ApiService.ValidateDisbursementExecute(r)
}

/*
ValidateDisbursement Method for ValidateDisbursement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param locator
	@return ApiValidateDisbursementRequest
*/
func (a *DisbursementsControllerAPIService) ValidateDisbursement(ctx context.Context, locator string) ApiValidateDisbursementRequest {
	return ApiValidateDisbursementRequest{
		ApiService: a,
		ctx:        ctx,
		locator:    locator,
	}
}

// Execute executes the request
//
//	@return DisbursementResponse
func (a *DisbursementsControllerAPIService) ValidateDisbursementExecute(r ApiValidateDisbursementRequest) (*DisbursementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DisbursementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisbursementsControllerAPIService.ValidateDisbursement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disbursements/{locator}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"locator"+"}", url.PathEscape(parameterValueToString(r.locator, "locator")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
